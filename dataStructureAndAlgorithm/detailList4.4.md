4.4算法
1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗
 时间复杂度
    1.常数阶  O(1)
    2.线性阶  O(n) 循环
    3.对数阶  O(logn) 
    4.平方阶  O(n^2) 嵌套循环
    5.指数阶  O(2^n)
    6.阶乘阶  O(n!)
    O(1)＜O(log2n)＜O(n)＜O(nlog2n)＜O(n2)＜O(n3)＜…＜O(2^n)＜O(n!)＜O(n^n)
 空间复杂度
    若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)
    递归，多次创建值  空间复杂度为O(n)
2.至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度
    文章：https://blog.csdn.net/weixin_33910434/article/details/91396623
    稳定性好处：排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就 是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的，比如给一群人先按年龄排序，如果是稳定的相同年龄的他们其他属性就可以对应到每个人，如果不稳点，相同年龄的顺序可能会发生变化，那就无法对应他的其他属性
    冒泡排序 空间复杂度O(1)  时间复杂度O(n^2)
        大致流程：
        1.从第一个元素开始，比较每两个相邻元素，如果前者大，就交换位置
        2.每次遍历结束，能够找到该次遍历过的元素中的最大值
        3.如果还有没排序过的元素，继续1
    选择排序 空间复杂度O(1)  时间复杂度O(n^2)  不稳定
        大致流程：
        1.取出未排序部分的第一个元素，遍历该元素之后的部分并比较大小。对于第一次遍历，就是取出第一个元素
        2.如果有更小的，与该元素交换位置
        3.每次遍历都能找出剩余元素中的最小值并放在已排序部分的最后
    堆排序 空间复杂度O(1)  时间复杂度O(n logn) 不稳定
        大致流程：
        1.建最大堆：把数组整理为最大堆的顺序，那么堆的根节点，或者说数组的第一个元素，就是最大的值
        2.排序：把最大值与未排序部分的最后一个元素交换，剩余的部分继续调整为最大堆。每次建堆都能找到剩余元素中最大的一个,在和未排序的最后一个换位置循环12步骤
    插入排序 空间复杂度O(1)  时间复杂度O(n^2)
        大致流程：
        1.取未排序部分的第一个元素。第一次遍历时，将第一个元素作为已排序元素，从第二个元素开始取
        2.遍历前面的已排序元素，并与这个未排序元素比较大小，找到合适的位置插入
        3.继续执行1
    希尔排序 空间复杂度O(1)  时间复杂度O(n log^2 n) 不稳定
       大致流程：（分组的插入排序）
        1.共三层循环，外层循环用来逐步减少 gap 的值
        2.中层与内层两层循环基本上就是插入排序，细节上的不同直接看代码就好，不再赘述 
    快速排序 空间复杂度O(logn)  时间复杂度O(n^2) 不稳定
        1.选择一个基准元素 pivot，比如第一个元素（当然可以选其他元素，但是最后会递归至只剩一个元素，所以还是选第一个元素比较靠谱）
        2.遍历数组，比 pivot 更小的元素创建一个数组，更大的创建一个数组，相等的也创建一个数组
        3.递归大小两个数组，继续执行1，直到数组只剩1个元素；递归的同时把这三部分连接起来
    归并排序 空间复杂度O(n)  时间复杂度O(n logn)
        大致流程：
        1.递归地把数组分割成前后两个子数组，直到数组中只有1个元素
            直接分两半，不用排序
        2.同时，递归地从两个数组中挨个取元素，比较大小并合并
    计数排序 空间复杂度O(k)	 时间复杂度O(n+k)
        大致流程：
        1.遍历数组，找出每个元素出现的次数，放入统计数组
        2.遍历统计数组，放入结果数组
    桶排序 空间复杂度O(n+k)  时间复杂度O(n^2)
       基本流程：
        1.初始化指定个数的桶
        2.找到数组的最大值和最小值，作差并除以桶数，就得到了每个桶中值的范围 range
        3.遍历数组，每个元素的值除以 range，商的整数部分即对应的桶的索引，放入该桶
        4.入桶时，可以立即执行排序，而不只是单单的 push()，比如使用插入排序
        5.遍历结束时，每个桶中的元素都是排序好的。并且因为桶也是按顺序摆放的，直接把所有的桶按顺序 concat起来即可 
    基数排序 空间复杂度O(n+k)  时间复杂度O(n*k)	
        要求元素必须是0或正整数 不能对小数排序
        LSD:（先把个位的按顺序排好，再把高位的按顺序排）
            1.找出最大元素，并获取其位数（长度） max_len
            2.外层循环以 max_len 作为遍历次数，从个位开始；内层循环遍历数组
            3.每次外层循环，都比较元素该位上的数字
            4.每次外层循环的最开始，先初始化 10 个数组，或者叫做桶，表示该位上的数字是 0-9 其中的一个
            5.内层遍历根据每个元素当前位上的值放到对应的桶里
            6.每次外层循环结束，把 10 个桶里的元素按顺序取出，并覆盖原数组，得到一个排序过后的数组
        MSD:
            1.找出最大元素，获取位数
            2.从最高位开始，比较每个元素相同位置上的数字，分桶
            3.如果还没比较到个位，那么递归每个不为空的桶，继续比较他们的下一位
3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用
    递归：递归是内部调用这个函数本身（复杂问题）
          虽然有代码简洁的优点，但是时间和空间消耗比较大。每一次函数调用都需要在内存栈中分配空间以保存参数，返回地址以及临时变量，而且往栈里面压入数据和弹出都需要时间
          递归还有栈溢出的问题，每个进程的栈容量是有限的
    循环：通过设置初始值和终止条件，在一个范围内重复运算（简单问题）
         代码可读性不如递归 
         但是效率更高   
4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题
    文章：https://blog.csdn.net/dcj0913/article/details/39271721
    1.贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解
    贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关
    2. 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径按照深度优先搜索的策略，一步一步返回，还原状态
    3.分治算法把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并
    （1）二分搜索
    （2）大整数乘法
    （3）Strassen矩阵乘法
    （4）棋盘覆盖
    （5）合并排序
    （6）快速排序
    （7）线性时间选择
    （8）最接近点对问题
    （9）循环赛日程表
    （10）汉诺塔
    4.动态规划基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息. 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）
    5.分支限界法回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解
      回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树
      最优路径
5.前端处理海量数据的算法方案 worker.js
    文章：https://blog.csdn.net/huang100qi/article/details/89303555
    纯计算的：
    1.分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。
    2.Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。
    3.Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。
    4.Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。
    5.Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。