1.3作用域和闭包
1.理解词法作用域和动态作用域（morphologyScope.html）
  js中只有词法作用域没有真正的动态作用域，作用域是在代码书写时确定的
  但是通过eval和with都可以用来修改词法作用域
2.理解JavaScript的作用域和作用域链（scope.html）
    作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期，变量的作用域有全局作用域和局部作用域两种
    全局作用域： 最外层函数和在最外层函数外面定义的变量拥有全局作用域
                所有末定义直接赋值的变量自动声明为拥有全局作用域
                所有window对象的属性拥有全局作用域
    局部作用域： 和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为             函数作用域，但是内部的作用域是可以访问到外层作用域的变量，反之是不行的
    块级作用域： 通过新增的let和const,所声明的变量在指定块的作用域外无法被访问,创建方式：
                    1.在一个函数内部
                    2.在一个代码块（由一对花括号）内部
                特点：
                1.声明变量不会提升到代码块顶部
                2.禁止重复声明
                3.在循环运算中，用let声明i,当前i的值只有在本轮中有效，每一轮其实都是新的变量，用var定义其实就是一个全局变量
    作用域链：父级没有，再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链
3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题(jsContext.html)  
  文章：https://www.cnblogs.com/fundebug/p/understand-javascript-context-and-stack.html
  执行上下文：执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行
  分为：
  1.全局执行上下文：这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这                 个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。
  2.函数执行上下文：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。                  一个程序中可以存在任意数量的函数执行上下文。
  3.Eval 函数执行上下文：运行在 eval 函数中的代码也获得了自己的执行上下文,只不过严格模式执行eval函数，不会作用于它的外层作用域，所以修改不会生                 效，非严格模式作用于他外层的作用域。
执行上下文栈的生命周期：创建->执行->回收
   创建：1.创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。
        2.创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。
        3.确定 this 指向
    执行：执行变量赋值、代码执行
    回收：执行上下文出栈等待虚拟机回收执行上下文

    变量提升：当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值
             函数有形参的话，会先给形参赋值，在进行函数和变量的提升

this指向： this 的值是在执行的时候才能确认，定义的时候不能确认
    各种情况：
    1.直接调用函数，那么函数中的this,不管在哪里都是windows对象。严格模式下，直接调用的函数的内部this是undefined
    2.谁调用了函数，谁就是 this, 比如obj.方法名(), 那么这个this就是Obj对象
    3.在构造函数模式中，类中(函数体中)出现的 this.xxx=xxx 中的 this 是当前类的一个实例
    4.call、apply 和 bind：this 是第一个参数
    5.箭头函数 this 指向:箭头函数没有自己的 this，看其外层的是否有函数，如果有，外层函数的 this 就是内部箭头函数的 this，如果没有，则 this 是 window。
执行上下文栈 :
    1.JavaScript 执行在单线程上，所有的代码都是排队执行
    2.一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部
    3.每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。
    4.浏览器的 JS 执行引擎总是访问栈顶的执行上下文。
    5.全局上下文只有唯一的一个，它在浏览器关闭时出栈。
    var color = "blue";
    function changeColor() {
        var anotherColor = "red";
        function swapColors() {
            var tempColor = anotherColor;
            anotherColor = color;
            color = tempColor;
        }
        swapColors();
    }
    changeColor();
    1.当上述代码在浏览器中加载时，JavaScript 引擎会创建一个全局执行上下文并且将它推入当前的执行栈
    2.调用 changeColor 函数时，此时 changeColor 函数内部代码还未执行，js 执行引擎立即创建一个 changeColor 的执行上下文（简称 EC），然后把这执行上下文压入到执行栈（简称 ECStack）中。
    3.执行 changeColor 函数过程中，调用 swapColors 函数，同样地，swapColors 函数执行之前也创建了一个 swapColors 的执行上下文，并压入到执行栈中。
    4.swapColors 函数执行完成，swapColors 函数的执行上下文出栈，并且被销毁。
    5.changeColor 函数执行完成，changeColor 函数的执行上下文出栈，并且被销毁。

4.this的原理以及几种不同使用场景的取值
    this： this 的值是在执行的时候才能确认，定义的时候不能确认，是函数执行上下文的一部分，指的是函数运行时所在的环境
    各种情况：
    1.直接调用函数，那么函数中的this,不管在哪里都是windows对象。严格模式下，直接调用的函数的内部this是undefined
    2.谁调用了函数，谁就是 this, 比如obj.方法名(), 那么这个this就是Obj对象
    3.在构造函数模式中，类中(函数体中)出现的 this.xxx=xxx 中的 this 是当前类的一个实例
    4.call、apply 和 bind：this 是第一个参数
    5.箭头函数 this 指向:箭头函数没有自己的 this，看其外层的是否有函数，如果有，外层函数的 this 就是内部箭头函数的 this，如果没有，则 this 是 window。
